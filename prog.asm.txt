.data
	user_input: .space 1001  #1000 characters and a new line character
	user_prompt: .asciiz "Enter a hexadecimal number: \n" 
.text
	main: #Label for instructions part of the program
	
		li $v0, 4   		#Call code for printing string	
		la $a0, user_prompt 	#Argument register now has address of user_prompt
		syscall 		#String is printed 

		li $v0, 8   #Call code for reading string
		la $t0, user_input #register $t0 has address of user_input in memory
		la $a0, ($t0) #Argument register $a0 has paramter the address in $t0
		li $a1, 1001	#OS knows the max byte in memory
		syscall 	#The user_input string is stored in user_input label in memory, whose address is in $t0



		la $t9, 1001($t0)   #Register $t9 stores the byte next to the byte last allocated of user_input in memory

		
		beq $t0, $t9, end_reached
		la $t1, ($t0)
		
		beq $t1, 44, string_end_found 
			beq $t1, 0, end_reached #The moving register if finds /0 or /n. has to end the program
			beq $t1, 10, end_reached
			
			#Check character valdity here by calling the character validating function
			#If invalid, chracters from $t0 to $t1 are put as it is 
			#If valid, branch to a hexadecimal converter procedure

			la $t0, ($t1)
			la $t1, 1($t1)



		
		check_if_end:
			beq $t0, 10, end_prog		#If $t0 reaches the end of character bytes, go to end label
			addi $t1, $t0, 0

		loop_thorugh_string:
			lb $t2, 0($t1)
			beq $t2, 27, end_string		#If $t2 has value equal to ascii value of a comma, a complete string has been found
			addi $t1, $t1, 1
			j loop_through_string

		end_of_string:

		end_prog:
			li $v0, 10 
			syscall
	
